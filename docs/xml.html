<html><head>
        <META http-equiv="content-type" content="text/html; charset=utf-8">
        <title>kxml.xml</title>
        </head><body>
        <h1>kxml.xml</h1>
        <!-- Generated by Ddoc from ../../../../.dub/packages/kxml-1.0.1/source/kxml/xml.d -->
KXML contains functions and classes for reading, parsing, and writing XML
 documents.
<br><br>
<b>Authors:</b><br>
William K. Moore, III
<br><br>
<b>License:</b><br>
Boost Software License - Version 1.0 - August 17th, 2003
<br><br>

 Permission is hereby granted, free of charge, to any person or organization
 obtaining a copy of the software and accompanying documentation covered by
 this license (the "Software") to use, reproduce, display, distribute,
 execute, and transmit the Software, and to prepare derivative works of the
 Software, and to permit third-parties to whom the Software is furnished to
 do so, all subject to the following:
<br><br>

 The copyright notices in the Software and this entire statement, including
 the above license grant, this restriction and the following disclaimer,
 must be included in all copies of the Software, in whole or in part, and
 all derivative works of the Software, unless such copies or derivative
 works are solely in the form of machine-executable object code generated by
 a source language processor.
<br><br>

 THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
 SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
 FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
 ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
 DEALINGS IN THE SOFTWARE.

<br><br>
<b>Standards:</b><br>
Attempts to conform to XML 1.0 Specification<br><br>

<dl><dt><big><a name="readDocument"></a>XmlNode <u>readDocument</u>(string <i>src</i>, bool <i>preserveWS</i> = false);
</big></dt>
<dd>Read an entire string into a tree of XmlNodes.
 This defaults to stripping all whitespace for a speed gain (less objects created), but can be forced to preserve whitespace using the second parameter.
<br><br>
<b>Example:</b><br>
<pre class="d_code">string xmlstring = <font color=red>"&lt;message responseID=\"1234abcd\" text=\"weather 12345\" type=\"message\"&gt;&lt;flags&gt;triggered&lt;/flags&gt;&lt;flags&gt;targeted&lt;/flags&gt;&lt;/message&gt;"</font>;
XmlNode xml = xmlstring.<u>readDocument</u>();
xmlstring = xml.toString;
<font color=green>// ensure that the string doesn't mutate after a second reading, it shouldn't
</font><font color=blue>debug</font>(xml)logline(<font color=red>"kxml.xml unit test\n"</font>);
<font color=blue>assert</font>(xmlstring.<u>readDocument</u>().toString == xmlstring);
<font color=blue>debug</font>(xpath)logline(<font color=red>"kxml.xml XPath unit test\n"</font>);
XmlNode[]searchlist = xml.parseXPath(<font color=red>"message/flags"</font>);
<font color=blue>assert</font>(searchlist.length == 2 &amp;&amp; searchlist[0].getName == <font color=red>"flags"</font>);

<font color=blue>debug</font>(xpath)logline(<font color=red>"kxml.xml deep XPath unit test\n"</font>);
searchlist = xml.parseXPath(<font color=red>"//message//flags"</font>);
<font color=blue>assert</font>(searchlist.length == 2 &amp;&amp; searchlist[0].getName == <font color=red>"flags"</font>);

<font color=blue>debug</font>(xpath)logline(<font color=red>"kxml.xml attribute match XPath unit test\n"</font>);
searchlist = xml.parseXPath(<font color=red>"/message[@type=\"message\" and @responseID=\"1234abcd\"]/flags"</font>);
<font color=blue>assert</font>(searchlist.length == 2 &amp;&amp; searchlist[0].getName == <font color=red>"flags"</font>);
searchlist = xml.parseXPath(<font color=red>"message[@type=\"toaster\"]/flags"</font>);
<font color=blue>assert</font>(searchlist.length == 0);
</pre>
<br><br>
<b>Returns:</b><br>
An XmlNode with no name that is the root of the document that was read.
<br><br>
<b>Throws:</b><br>
XmlError on any parsing errors.<br><br>

</dd>
<dt><big><a name="XmlError"></a>class <u>XmlError</u>: <u>object.Exception</u>;
</big></dt>
<dd>An exception thrown on an xml parsing error.<br><br>

</dd>
<dt><big><a name="XPathError"></a>class <u>XPathError</u>: <u>object.Exception</u>;
</big></dt>
<dd>An exception thrown on an XPath parsing error.<br><br>

</dd>
<dt><big><a name="XmlNode"></a>class <u>XmlNode</u>;
</big></dt>
<dd><u>XmlNode</u> represents a single xml node and has methods for modifying
 attributes and adding children.  All methods that make changes modify this
 <u>XmlNode</u> rather than making a copy, unless otherwise noted.  Many methods
 return a self reference to allow cascaded calls.
<br><br>
<b>Example:</b><br>
<pre class="d_code"><font color=green>// Create an XmlNode tree with attributes and cdata, and write it to a file.
</font>node.addChild(<font color=blue>new</font> <u>XmlNode</u>(<font color=red>"mynode"</font>).setAttribute(<font color=red>"x"</font>, 50).
    addChild(<font color=blue>new</font> <u>XmlNode</u>(<font color=red>"Waldo"</font>).addCData(<font color=red>"Hello!"</font>))).write(<font color=red>"myfile.xml"</font>);
</pre>
<br><br>

<dl><dt><big><a name="XmlNode.this"></a>this();
</big></dt>
<dd>Construct an empty XmlNode.<br><br>

</dd>
<dt><big><a name="XmlNode.this.2"></a>this(string <i>name</i>);
</big></dt>
<dd>Construct and set the <i>name</i> of this XmlNode.<br><br>

</dd>
<dt><big><a name="XmlNode.getName"></a>string <u>getName</u>();
</big></dt>
<dd>Get the name of this XmlNode.<br><br>

</dd>
<dt><big><a name="XmlNode.setName"></a>void <u>setName</u>(string <i>newName</i>);
</big></dt>
<dd>Set the name of this XmlNode.<br><br>

</dd>
<dt><big><a name="XmlNode.hasAttribute"></a>bool <u>hasAttribute</u>(string <i>name</i>);
</big></dt>
<dd>Does this XmlNode have the specified attribute?<br><br>

</dd>
<dt><big><a name="XmlNode.getAttribute"></a>string <u>getAttribute</u>(string <i>name</i>);
</big></dt>
<dd>Get the specified attribute, or return <b>null</b> if the XmlNode doesn't have that attribute.<br><br>

</dd>
<dt><big><a name="XmlNode.getAttributes"></a>string[string] <u>getAttributes</u>();
</big></dt>
<dd>Return an array of all attributes (does a single pass of XML entity decoding like &quot; -&gt; ").<br><br>

</dd>
<dt><big><a name="XmlNode.setAttribute"></a>XmlNode <u>setAttribute</u>(string <i>name</i>, string <i>value</i>);
</big></dt>
<dd>Set an attribute to a string <i>value</i>.
<br><br>
The attribute is created if it doesn't exist.<br><br>

</dd>
<dt><big><a name="XmlNode.setAttribute.2"></a>XmlNode <u>setAttribute</u>(string <i>name</i>, long <i>value</i>);
</big></dt>
<dd>Set an attribute to an integer <i>value</i> (stored internally as a string).
<br><br>
The attribute is created if it doesn't exist.<br><br>

</dd>
<dt><big><a name="XmlNode.setAttribute.3"></a>XmlNode <u>setAttribute</u>(string <i>name</i>, float <i>value</i>);
</big></dt>
<dd>Set an attribute to a float <i>value</i> (stored internally as a string).
<br><br>
The attribute is created if it doesn't exist.<br><br>

</dd>
<dt><big><a name="XmlNode.removeAttribute"></a>XmlNode <u>removeAttribute</u>(string <i>name</i>);
</big></dt>
<dd>Remove the attribute with <i>name</i>.<br><br>

</dd>
<dt><big><a name="XmlNode.addChild"></a>XmlNode <u>addChild</u>(XmlNode <i>newNode</i>);
</big></dt>
<dd>Add a child node.<br><br>

</dd>
<dt><big><a name="XmlNode.getChildren"></a>XmlNode[] <u>getChildren</u>();
</big></dt>
<dd>Get all child nodes associated with this object.
<br><br>
<b>Returns:</b><br>
An raw, uncopied array of all child nodes.<br><br>

</dd>
<dt><big><a name="XmlNode.removeChild"></a>size_t <u>removeChild</u>(XmlNode <i>remove</i>);
</big></dt>
<dd>Remove the child with the same reference as what was given.
<br><br>
<b>Returns:</b><br>
The number of children removed.<br><br>

</dd>
<dt><big><a name="XmlNode.addCData"></a>XmlNode <u>addCData</u>(string <i>cdata</i>);
</big></dt>
<dd>Add a child Node of <i>cdata</i> (text).<br><br>

</dd>
<dt><big><a name="XmlNode.isCData"></a>final bool <u>isCData</u>();
</big></dt>
<dd>Check to see if this node is a CData node.<br><br>

</dd>
<dt><big><a name="XmlNode.isXmlPI"></a>final bool <u>isXmlPI</u>();
</big></dt>
<dd>Check to see if this node is a XmlPI node.<br><br>

</dd>
<dt><big><a name="XmlNode.isXmlComment"></a>final bool <u>isXmlComment</u>();
</big></dt>
<dd>Check to see if this node is a XmlComment node.<br><br>

</dd>
<dt><big><a name="XmlNode.getCData"></a>string <u>getCData</u>();
</big></dt>
<dd>This function makes life easier for those looking to pull cdata from a tag, in the case of multiple nodes, it pulls all first level cdata nodes.<br><br>

</dd>
<dt><big><a name="XmlNode.reset"></a>void <u>reset</u>();
</big></dt>
<dd>This function resets the node to a default state<br><br>

</dd>
<dt><big><a name="XmlNode.removeChildren"></a>XmlNode <u>removeChildren</u>();
</big></dt>
<dd>This function removes all child nodes from the current node<br><br>

</dd>
<dt><big><a name="XmlNode.setCData"></a>XmlNode <u>setCData</u>(string <i>cdata</i>);
</big></dt>
<dd>This function sets the <i>cdata</i> inside the current node as intelligently as possible (without allocation, hopefully)<br><br>

</dd>
<dt><big><a name="XmlNode.getInnerXML"></a>string <u>getInnerXML</u>();
</big></dt>
<dd>This function gives you the inner xml as it would appear in the document.<br><br>

</dd>
<dt><big><a name="XmlNode.toString"></a>string <u>toString</u>();
</big></dt>
<dd>This function dumps the xml structure to a string with no newlines and no linefeeds to be output.<br><br>

</dd>
<dt><big><a name="XmlNode.write"></a>deprecated string <u>write</u>(string <i>indent</i> = null);
</big></dt>
<dd>This is the old pretty string output function.  It is deprecated in favor of toPrettyString.<br><br>

</dd>
<dt><big><a name="XmlNode.toPrettyString"></a>string <u>toPrettyString</u>(string <i>indent</i> = null);
</big></dt>
<dd>This function dumps the xml structure in to pretty, tabbed format.<br><br>

</dd>
<dt><big><a name="XmlNode.addChildren"></a>void <u>addChildren</u>(string <i>xsrc</i>, bool <i>preserveWS</i>);
</big></dt>
<dd>Add children from a string containing valid xml.<br><br>

</dd>
<dt><big><a name="XmlNode.addChildren.2"></a>void <u>addChildren</u>(XmlNode[] <i>newChildren</i>);
</big></dt>
<dd>Add array of nodes directly into this node as children.<br><br>

</dd>
<dt><big><a name="XmlNode.parseXPath"></a>XmlNode[] <u>parseXPath</u>(string <i>xpath</i>, bool <i>caseSensitive</i> = false);
</big></dt>
<dd>Do an XPath search on this node and return all matching nodes.
<br><br>
This function does not perform any modifications to the tree and so does not support XML mutation.<br><br>

</dd>
<dt><big><a name="XmlNode.opIndex"></a>string <u>opIndex</u>(string <i>attr</i>);
</big></dt>
<dd>Index override for getting attributes.<br><br>

</dd>
<dt><big><a name="XmlNode.opIndex.2"></a>XmlNode <u>opIndex</u>(size_t <i>childnum</i>);
</big></dt>
<dd>Index override for getting children.<br><br>

</dd>
<dt><big><a name="XmlNode.opIndexAssign"></a>XmlNode <u>opIndexAssign</u>(string <i>value</i>, string <i>name</i>);
</big></dt>
<dd>Index override for setting attributes.<br><br>

</dd>
<dt><big><a name="XmlNode.opIndexAssign.2"></a>XmlNode <u>opIndexAssign</u>(XmlNode <i>x</i>, int <i>childnum</i>);
</big></dt>
<dd>Index override for replacing children.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="CData"></a>class <u>CData</u>: <u>kxml.xml.XmlNode</u>;
</big></dt>
<dd>A class specialization for <u>CData</u> nodes.<br><br>

<dl><dt><big><a name="CData.this"></a>this(string <i>cdata</i>);
</big></dt>
<dd>Override the string constructor, assuming the data is coming from a user program, possibly with unescaped XML entities that need escaping.<br><br>

</dd>
<dt><big><a name="CData.getCData"></a>string <u>getCData</u>();
</big></dt>
<dd>Get CData string associated with this object.
<br><br>
<b>Returns:</b><br>
Parsed Character Data with decoded XML entities<br><br>

</dd>
<dt><big><a name="CData.setCData"></a>CData <u>setCData</u>(string <i>cdata</i>);
</big></dt>
<dd>This function assumes data is coming from user input, possibly with unescaped XML entities that need escaping.<br><br>

</dd>
<dt><big><a name="CData.reset"></a>void <u>reset</u>();
</big></dt>
<dd>This function resets the node to a default state<br><br>

</dd>
<dt><big><a name="CData.toString"></a>protected string <u>toString</u>();
</big></dt>
<dd>This outputs escaped XML entities for use on the network or in a document.<br><br>

</dd>
<dt><big><a name="CData.write"></a>deprecated protected string <u>write</u>(string <i>indent</i> = null);
</big></dt>
<dd>Deprecated pretty writer<br><br>

</dd>
<dt><big><a name="CData.toPrettyString"></a>protected string <u>toPrettyString</u>(string <i>indent</i> = null);
</big></dt>
<dd>This outputs escaped XML entities for use on the network or in a document in pretty, tabbed format.<br><br>

</dd>
<dt><big><a name="CData.getName"></a>string <u>getName</u>();
</big></dt>
<dd>This throws an exception because CData nodes do not have names.<br><br>

</dd>
<dt><big><a name="CData.setName"></a>void <u>setName</u>(string <i>newName</i>);
</big></dt>
<dd>This throws an exception because CData nodes do not have names.<br><br>

</dd>
<dt><big><a name="CData.hasAttribute"></a>bool <u>hasAttribute</u>(string <i>name</i>);
</big></dt>
<dd>This throws an exception because CData nodes do not have attributes.<br><br>

</dd>
<dt><big><a name="CData.getAttribute"></a>string <u>getAttribute</u>(string <i>name</i>);
</big></dt>
<dd>This throws an exception because CData nodes do not have attributes.<br><br>

</dd>
<dt><big><a name="CData.getAttributes"></a>string[string] <u>getAttributes</u>();
</big></dt>
<dd>This throws an exception because CData nodes do not have attributes.<br><br>

</dd>
<dt><big><a name="CData.setAttribute"></a>XmlNode <u>setAttribute</u>(string <i>name</i>, string <i>value</i>);
</big></dt>
<dd>This throws an exception because CData nodes do not have attributes.<br><br>

</dd>
<dt><big><a name="CData.setAttribute.2"></a>XmlNode <u>setAttribute</u>(string <i>name</i>, long <i>value</i>);
</big></dt>
<dd>This throws an exception because CData nodes do not have attributes.<br><br>

</dd>
<dt><big><a name="CData.setAttribute.3"></a>XmlNode <u>setAttribute</u>(string <i>name</i>, float <i>value</i>);
</big></dt>
<dd>This throws an exception because CData nodes do not have attributes.<br><br>

</dd>
<dt><big><a name="CData.addChild"></a>XmlNode <u>addChild</u>(XmlNode <i>newNode</i>);
</big></dt>
<dd>This throws an exception because CData nodes do not have children.<br><br>

</dd>
<dt><big><a name="CData.addCData"></a>XmlNode <u>addCData</u>(string <i>cdata</i>);
</big></dt>
<dd>This throws an exception because CData nodes do not have children.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="UCData"></a>class <u>UCData</u>: <u>kxml.xml.CData</u>;
</big></dt>
<dd>A specialization of CData for &lt;![CDATA[]]&gt; nodes<br><br>

<dl><dt><big><a name="UCData.getCData"></a>string <u>getCData</u>();
</big></dt>
<dd>Get CData string associated with this object.
<br><br>
<b>Returns:</b><br>
Unparsed Character Data<br><br>

</dd>
<dt><big><a name="UCData.setCData"></a>CData <u>setCData</u>(string <i>cdata</i>);
</big></dt>
<dd>This function assumes data is coming from user input, possibly with unescaped XML entities that need escaping.<br><br>

</dd>
<dt><big><a name="UCData.reset"></a>void <u>reset</u>();
</big></dt>
<dd>This function resets the node to a default state<br><br>

</dd>
<dt><big><a name="UCData.toString"></a>protected string <u>toString</u>();
</big></dt>
<dd>This outputs escaped XML entities for use on the network or in a document.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="XmlPI"></a>class <u>XmlPI</u>: <u>kxml.xml.XmlNode</u>;
</big></dt>
<dd>A class specialization for XML instructions.<br><br>

<dl><dt><big><a name="XmlPI.this"></a>this(string <i>name</i>);
</big></dt>
<dd>Override the constructor that takes a <i>name</i> so that it's accessible.<br><br>

</dd>
<dt><big><a name="XmlPI.getCData"></a>string <u>getCData</u>();
</big></dt>
<dd>This node can't have children, and so can't have CData.
<br><br>
Should this throw an exception?<br><br>

</dd>
<dt><big><a name="XmlPI.toString"></a>string <u>toString</u>();
</big></dt>
<dd>Override <u>toString</u> for output to be used by parsers.<br><br>

</dd>
<dt><big><a name="XmlPI.reset"></a>void <u>reset</u>();
</big></dt>
<dd>This function resets the node to a default state<br><br>

</dd>
<dt><big><a name="XmlPI.write"></a>deprecated protected string <u>write</u>(string <i>indent</i> = null);
</big></dt>
<dd>Deprecated pretty print to be used by parsers.<br><br>

</dd>
<dt><big><a name="XmlPI.toPrettyString"></a>protected string <u>toPrettyString</u>(string <i>indent</i> = null);
</big></dt>
<dd>Pretty print to be used by parsers.<br><br>

</dd>
<dt><big><a name="XmlPI.addChild"></a>XmlNode <u>addChild</u>(XmlNode <i>newNode</i>);
</big></dt>
<dd>You can't add a child to something that can't have children.  There is no adoption in XML world.<br><br>

</dd>
<dt><big><a name="XmlPI.addCData"></a>XmlNode <u>addCData</u>(string <i>cdata</i>);
</big></dt>
<dd>You can't add a child to something that can't have children.  There is no adoption in XML world.
<br><br>
Especially for red-headed stepchildren CData nodes.<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="XmlComment"></a>class <u>XmlComment</u>: <u>kxml.xml.XmlNode</u>;
</big></dt>
<dd>A class specialization for XML comments.<br><br>

<dl><dt><big><a name="XmlComment.getCData"></a>string <u>getCData</u>();
</big></dt>
<dd>This node can't have children, and so can't have CData.
<br><br>
Should this throw an exception?<br><br>

</dd>
<dt><big><a name="XmlComment.reset"></a>void <u>reset</u>();
</big></dt>
<dd>This function resets the node to a default state<br><br>

</dd>
<dt><big><a name="XmlComment.toString"></a>string <u>toString</u>();
</big></dt>
<dd>Override <u>toString</u> for output to be used by parsers.<br><br>

</dd>
<dt><big><a name="XmlComment.write"></a>deprecated protected string <u>write</u>(string <i>indent</i> = null);
</big></dt>
<dd>Deprecated pretty print to be used by parsers.<br><br>

</dd>
<dt><big><a name="XmlComment.toPrettyString"></a>protected string <u>toPrettyString</u>(string <i>indent</i> = null);
</big></dt>
<dd>Pretty print to be used by parsers.<br><br>

</dd>
<dt><big><a name="XmlComment.getName"></a>string <u>getName</u>();
</big></dt>
<dd>The members of Project Mayhem have no name... (this throws an exception)<br><br>

</dd>
<dt><big><a name="XmlComment.setName"></a>void <u>setName</u>(string <i>newName</i>);
</big></dt>
<dd>Ditto. (this throws an exception)<br><br>

</dd>
<dt><big><a name="XmlComment.hasAttribute"></a>bool <u>hasAttribute</u>(string <i>name</i>);
</big></dt>
<dd>These events can not be attributed to space monkeys. (this throws an exception)<br><br>

</dd>
<dt><big><a name="XmlComment.getAttribute"></a>string <u>getAttribute</u>(string <i>name</i>);
</big></dt>
<dd>Ditto. (this throws an exception)<br><br>

</dd>
<dt><big><a name="XmlComment.getAttributes"></a>string[string] <u>getAttributes</u>();
</big></dt>
<dd>Ditto. (this throws an exception)<br><br>

</dd>
<dt><big><a name="XmlComment.setAttribute"></a>XmlNode <u>setAttribute</u>(string <i>name</i>, string <i>value</i>);
</big></dt>
<dd>Ditto. (this throws an exception)<br><br>

</dd>
<dt><big><a name="XmlComment.setAttribute.2"></a>XmlNode <u>setAttribute</u>(string <i>name</i>, long <i>value</i>);
</big></dt>
<dd>Ditto. (this throws an exception)<br><br>

</dd>
<dt><big><a name="XmlComment.setAttribute.3"></a>XmlNode <u>setAttribute</u>(string <i>name</i>, float <i>value</i>);
</big></dt>
<dd>Ditto. (this throws an exception)<br><br>

</dd>
<dt><big><a name="XmlComment.addChild"></a>XmlNode <u>addChild</u>(XmlNode <i>newNode</i>);
</big></dt>
<dd>Comments don't have children. (this throws an exception)<br><br>

</dd>
<dt><big><a name="XmlComment.addCData"></a>XmlNode <u>addCData</u>(string <i>cdata</i>);
</big></dt>
<dd>Ditto. (this throws an exception)<br><br>

</dd>
</dl>
</dd>
<dt><big><a name="prealloc"></a>int <u>prealloc</u>;
</big></dt>
<dd>This is the encapsulating class for xml documents that allows reuse of nodes
 so as to not allocate ALL THE TIME if you find it convenient to reuse the structure
<br><br>
<b>Example:</b><br>
<pre class="d_code"> string xmlstring = <font color=red>"&lt;message responseID=\"1234abcd\" text=\"weather 12345\" type=\"message\"&gt;&lt;flags&gt;triggered&lt;/flags&gt;&lt;flags&gt;targeted&lt;/flags&gt;&lt;/message&gt;"</font>;
 <font color=green>// here we have the creation of an XmlDocument using the static opCall
</font> <font color=blue>auto</font> newdoc = XmlDocument(xmlstring);
 <font color=green>// reset rips apart the node tree to be reused
</font> newdoc.reset;
 <font color=green>// so reuse the XmlDocument that already has allocated nodes
</font> newdoc.parse(xmlstring);
 <font color=green>// here we have the creation of a secondary with a constructor
</font> newdoc = <font color=blue>new</font> XmlDocument();
 newdoc.parse(xmlstring);
 <font color=green>// and again with the parse constructor
</font> newdoc = <font color=blue>new</font> XmlDocument(xmlstring);
 <font color=green>// XmlDocuments act like XmlNodes without attributes or names, so you can add children
</font> newdoc.addCData(<font color=red>"A long long time ago, in a galaxy far far away..."</font>);
</pre>
<br><br>

</dd>
<dt><big><a name="xmlEncode"></a>string <u>xmlEncode</u>(string <i>src</i>);
</big></dt>
<dd>Encode characters such as &amp;, &lt;, &gt;, etc. as their xml/html equivalents<br><br>

</dd>
<dt><big><a name="xmlDecode"></a>string <u>xmlDecode</u>(string <i>src</i>);
</big></dt>
<dd>Convert xml-encoded special characters such as &amp;amp; back to &amp;.<br><br>

</dd>
</dl>

        <hr><small>Page generated by <a href="http://dlang.org/ddoc.html">Ddoc</a>. (c) 2009 William K. Moore, III (nyphbl8d (at) gmail (dot) com, opticron on freenode)
</small>
        </body></html>
